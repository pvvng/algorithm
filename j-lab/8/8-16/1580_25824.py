import sys
input = sys.stdin.readline

# (0, 1) => (2, 3) => (4, 5) => (6, 7) => (8, 9) => (10, 11)

### dfs로 풀이 (내 풀이)
def dfs(A, k):
  if k > 11:
    return 0
  
  # k -> sender 전달비용
  sender = k+1 if k % 2 == 0 else k-1
  ans = A[k][sender]

  # 현재 지점이 마지막인 경우 그룹끼리의 전달 비용만 넘기기
  if sender >= 10:
    return ans
  
  # k가 짝수일 때 n1, n2 = k+2, k+2+1
  # k가 홀수일 때 n1, n2 = k+2, k+2-1
  n1 = k+2
  n2 = k+2+1 if k % 2 == 0 else k+2-1

  # sender -> receiver 전달
  # reciver가 n1인 경우
  cost1 = A[sender][n1] + dfs(A, n1)
  # reciver가 n2인 경우
  cost2 = A[sender][n2] + dfs(A, n2)

  # 다음 그룹으로 패스
  return ans + min(cost1, cost2)

### dp를 이용한 풀이(책)
def sol(A):
  # D[k][0] ====> k 그룹에서 첫번째 학생(0)이 편지를 가지고 있을때 여기까지 도달하는데 걸리는 최소 시간
  # k 그룹에서 첫번째 학생(0) -> 두번째 학생(1)의 전달 시간 (A[k][k+1])
  # k-1 그룹에서 k 그룹의 첫번째 학생으로 편지를 전달하는 최소 시간
    # case 1: k-1 그룹의 첫번째 학생이 k 그룹의 첫번째 학생에게 편지를 전달하는 시간 (A[2*(k-1)][k])
    # case 2: k-1 그룹의 두번째 학생이 k 그룹의 첫번째 학생에게 편지를 전달하는 시간 (A[2*(k-1)+1][k])
  # k-1 그룹 이전까지 전달된 편지의 전달 시간 
    # case1: k-1 그룹에서 편지를 가지고 있는 사람이 첫번째 학생일 때 -> D[k-1][0]
    # case2: k-1 그룹에서 편지를 가지고 있는 사람이 첫번째 학생일 때 -> D[k-1][1]
  D = list([0] * 2 for _ in range(6))


  # D[0][0] => 0 그룹에서 첫번째 학생이 편지를 가지고 있는 시간 
  # 선생님 -> 0 그룹, 두번째 학생 -> 0 그룹, 첫번째 학생
  # 즉, A[1][0]
  D[0][0] = 0 + A[1][0]
  D[0][1] = 0 + A[0][1]

  # D[k][0], D[k][1]에 적절한 값을 기록하자.
  # D[k][0] 은 k 그룹의 첫번째 학생이 편지를 가지고 있는 상태일때 해당 상태가 되기까지 걸린 최솟값이다.
  for k in range(1, 6):
    # A[2*k+1][2*k] 전이는 반드시 가진다. k그룹의 두번째 학생이 첫번째 학생에게 반드시 편지를 넘겨야하기 때문
    # D[k][0] 상태가 되기 위한 2가지 케이스, 둘중 최솟값을 찾는다.
      # k-1 그룹에서 첫번째 학생(2*(k-1))이 편지를 가지고 있는 경우, 
        # k-1그룹의 첫번째 학생 -> k 그룹의 두번째 학생 (A[2*(k-1)][2*k+1]) + k-1 그룹의 첫번째 학생이 편지를 받기까지의 최솟값 (D[k-1][0])
      # k-1 그룹에서 두번째 학생(2*(k-1)+1)이 편지를 가지고 있는 경우,
        # k-1그룹의 두번째 학생 -> k 그룹의 두번째 학생 (A[2*(k-1)+1][2*k+1]) + k-1 그룹의 두번째 학생이 편지를 받기까지의 최솟값 (D[k-1][1])
    D[k][0] = min(D[k-1][0] + A[2*(k-1)][2*k+1] + A[2*k+1][2*k], \
                  D[k-1][1] + A[2*(k-1)+1][2*k+1] + A[2*k+1][2*k])

    # k 그룹의 두번째 학생이 편지를 가지고 있는 상태일때
    # 2*k -> 2*k+1 전이 (A[2*k][2*k+1])은 반드시 발생한다.

    # 2*(k-1) ==> k-1 그룹의 첫번째에서 k 그룹의 첫번째 학생으로 편지를 전달하는 경우
    # 2*(k-1) + 1 ==> k-1 그룹의 두번째에서 k 그룹의 첫번째 학생으로 편지를 전달하는 경우
    D[k][1] = min(D[k-1][0] + A[2*(k-1)][2*k] + A[2*k][2*k+1], \
                  D[k-1][1] + A[2*(k-1)+1][2*k] + A[2*k][2*k+1])

  return min(D[5][0], D[5][1])

A = [list(map(int, input().split())) for _ in range(12)]
print(sol(A))