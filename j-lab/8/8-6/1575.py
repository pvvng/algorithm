# 두 명의 학생이 1이상 n이하의 정수를 외치는 게임을 하고 있다. 
# 첫 번째 학생이 먼저 정수를 외친 후 두 명의 학생이 교대로 정수를 외친다. 
# 이전 학생이 외친 정수가 a이면 현재 학생은 (a + 1)이상 (a + k)이하의 정수를 외쳐야 한다. 
# 맨 처음 첫 번째 학생은 1이상 k이하의 정수를 외쳐야 한다. 
# 추가로, 두 명의 학생이 외칠 수 없는 정수 목록이 주어지고, 두 명의 학생은 목록에 있는 정수를 외칠 수 없다. 
# 마지막에 정수를 못 외치는 학생이 게임을 진다. 
# 현재 학생이 외칠 수 있는 정수가 여러 개이면, 외칠 수 있는 정수 중 하나를 외친다.
# 두 명의 학생이 규칙에 맞게 플레이했을 때, 첫 번째 학생이 이기면 1을 출력하고 두 번째 학생이 이기면 0을 출력한다.

import sys
input = sys.stdin.readline

def sol(n, k, A):
  B = [True] * (n + 1)
  for a in A:
    B[a] = False

  return dfs(n, k, 0, B)

# 현재 차례인 사람(=지금 말해야 하는 사람) 이 이 상태에서 이길 수 있으면 1, 지면 0 을 반환
def dfs(n, k, a, B):
  # Q: 왜 이전 학생이 n을 말했을 때 항상 두번째 학생이 이긴다고 확신할 수 있지?
  # 이전학생 == 두번째 학생이라는 전제가 선행되어야 하지 않나 그게 왜 가능한지 모르겠음

  # A: 함수의 관점에서 보면 이 함수는 현재 차례인 사람이 지면 0을 반환하는 함수임.
  # 현재 차례가 첫번째 학생인지, 두번째 학생인지는 중요하지 않음.
  # 따라서 현재 말할 수 있는 숫자가 없으므로 0을 반환하는 것.
  if a == n:
    return 0
  
  for b in range(a + 1, a + k + 1):
    if b > n:
      break

    if not B[b]:
      continue

    # Q: 이것도 마찬가지임
    # 왜 b를 외쳤을때 dfs 결과가 0이 나오면 현재 학생이 이기는거지?

    # A: 현재 차례인 사람이 b를 외쳤을때 상대가 패배하는 것임
    # dfs(~)함수는 초기 상태가 주어질 때 그 상태를 기준으로 결과를 판단함. 
    # 즉, dfs(n, k, b, B)는 다음 차례의 사람 => 현재 차례의 사람이 됨.
    # 따라서 다음 차례의 사람이 패배 => 현재 차례의 사람의 승리로 판단 가능해짐 
    if dfs(n, k, b, B) == 0:
      return 1
  
  # 현재 학생이 이길 수 있는 경우가 없으니 0을 반환하는건 이해함
  return 0

n, k = map(int, input().split())
A = list(map(int, input().split()))
print(sol(n, k, A))